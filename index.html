<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>First vue!</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
</head>
<body>
    <div id="app">
        {{ nextYear() }}
        <br>

        {{ nextYearGreeting(' Happy new year') }}
        <br>

        <input v-bind:type="type" v-bind:value="inputData">
        <input :type="type" :value="inputData">
        <br>

        <a :href="linkKossieCoder">코지코더 채널</a>
        <br>

        <a :href="getYoutubeLinkWithSuffix('kossiecoder')">함수로 얻은 채널</a>
        <br>

        <button onClick="alert('hello kossiecoder')">Click Me</button>
        <button v-on:click="alert">Click Me</button>
        <br>

        {{ currentValue }}
        <br>
        <button v-on:click="addCurrentValue()">Add value</button>
        <button v-on:click="subCurrentValue()">Subtract value</button>
        <br>

        <form v-on:submit="submit">
            <input type="text"><br>
            <button type="submit">Submit with refresh</button>
        </form><br>
        <form v-on:submit.prevent="submit">
            <input type="text"><br>
            <button type="submit">Submit without refresh</button>
        </form>

        <!-- 양방향 데이터 바인딩이 아닌 예제-->
        <form>
            <input type="text" :value="chap05Text" @keyup="updateText"><br> <!-- v-on:은 @로 대체가 가능하다 --> <!-- 함수 호출시 아무 파라미터를 주지 않아도 keyboard 관련 이벤트를 자동으로 넣어준다-->
            {{ chap05Text }}
        </form>
        <br>
        <!-- 양방향 데이터 바인딩을 사용한 예제 -->
        <form >
            <input type="text" v-model="chap05TextTwoWayBinding"><br> <!-- v-model을 이용한 양방향 데이터 바인딩을 사용하면 코드가 훨씬 간단하다 -->
            {{ chap05TextTwoWayBinding }}
        </form>

        <br><br>
        <!-- chap06 computed 속성-->
        {{ chap06Number + 1 }} <br> <!-- 이런 간단한 연산은 바로 집어넣어도 되지만 연산이 복잡해지면 유지보수가 어렵고 내용 파악도 어렵다 -->
        {{ chap06Message.split('').reverse().join('') }} <br> <!-- 문장을 거꾸로 뒤집어주는 함수. 이런게 많아지면 나중에 수정이 힘들다 -->
        {{ reversedMessage }} <br> <!-- computed를 사용하면 코드가 훨씬 좋아진다-->
        {{ reversedMessageMethodVersion() }} <br> <!-- 함수를 사용하면 ()를 붙여줘야 하고, computed속성은 ()를 붙이지 않아도 된다-->
        <!-- computed 속성은 캐싱을 하고, 함수는 캐싱을 하지 않는다. -->
        <!-- 함수는 10번 호출하면 10번 계산을 하지만, computed 속성은 처음 한번만 계산하면 돼서 성능에 이점이 있다. -->
        <!-- 만약 chap06Message가 변경되면 computed속성은 다시한번 계산해서 캐싱 해준다. -->
        <button @click="changeChap06Message">값 변경</button>
        <br><br>
        <!-- chap07 watch 속성 -->
        <!-- 보통 computed 속성 코드가 훨씬 간단하기 떄문에 computed를 쓸 수 없는 경우만 watch를 사용하자 -->
        {{ chap07Message }}<br>
        <button @click="changeChap07Message">watch</button><br>
        {{ chap07NewMessage }}
    </div>
    <script>
        new Vue({
            el: '#app',
            data: {
                person: {
                    name: 'Junyoung Ju',
                    age: 30
                },
                inputData: '1234',
                type: 'number',
                linkKossieCoder: 'https://www.youtube.com/kossiecoder',
                currentValue: 0,
                chap05Text: 'text',
                chap05TextTwoWayBinding: 'text',
                chap06Number: 1,
                chap06Message: '안녕하세요',
                chap07Message: 'watch메시지',
                chap07NewMessage: 'watch메시지'
            },
            methods: {
                nextYear: function() {
                    return this.person.name + ' will become ' + (this.person.age + 1) + ' years old';
                },
                nextYearGreeting(message) {
                    return this.nextYear() + message;
                },
                printInputData() {
                    return this.inputData;
                },
                getYoutubeLinkWithSuffix(suffix) {
                    return 'https://www.youtube.com/' + suffix
                },
                alert() {
                    alert('hi Kossiecoder')
                },
                addCurrentValue() {
                    this.currentValue++
                },
                subCurrentValue() {
                    this.currentValue--
                },
                submit() {
                    alert("submitted" + this.inputData2)
                },
                updateText(event) { // 이 event는 자동으로 받은 event 객체
                    this.chap05Text = event.target.value; // event.target.value가 현재 값을 가지고 있다
                },
                reversedMessageMethodVersion() {
                    return this.chap06Message.split('').reverse().join('')
                },
                changeChap06Message() {
                    this.chap06Message = "값이변경됨"
                },
                changeChap07Message() {
                    this.chap07Message = "watch 새로운 메시지" // chap07Message를 변경해준다.
                }
            },
            computed: {
                reversedMessage() {
                    return this.chap06Message.split('').reverse().join('')
                }
            },
            watch: {
                chap07Message(newVal, oldVal) { // 이름을 data와 맞춰야 한다. // chap07Message가 변경되는걸 감시한다
                    this.chap07NewMessage = "watch 새로운 메시지" // chap07Message가 변경될 때 chap07NewMessage도 변경시켜준다.
                }
            }
        })
    </script>
</body>
</html>